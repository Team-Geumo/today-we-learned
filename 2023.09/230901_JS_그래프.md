# [JavaScript] 그래프

## 1. 그래프

- 어떤 정보 간의 **연결 관계**를 나타내는데 특화된 자료구조
- **정점**이 있고, 정점 사이를 잇는 **간선**이 있음

<br>

## 2. 그래프의 표현

- 핵심: **어떤 정점과 어떤 정점이 간선으로 연결되어 있는지**를 잘 나타내는 것

<br>

### 2.1. 인접 행렬 (Adjacency Matrix)

- 어떤 정점이 연결되어 있는지를 **2차원 배열**을 이용해 나타내는 방식

  - 그래프로 표현하기 위해선 정점의 개수를 N이라고 할 때, N x N 크기의 배열이 필요

- 기본적으로 배열이 있는 모든 칸의 초기값은 `0`

  - 배열의 r행 c열에 있는 칸의 값이 `0`이라는 것은 r번 정점에서 c번 정점으로 가는 간선이 존재하지 않는다는 의미

- a번 정점에서 b번 정점으로 가는 간선이 존재하는 경우 a행 b열에 해당하는 칸을 `1`로 바꿈

  - `1`은 `0`과는 반대로 간선이 존재한다는 의미

- **양방향** 그래프라면 a행 b열에 해당하는 칸과 b행 a열에 해당하는 칸을 모두 표시해야 함

#### 장점

- 인접 행렬의 장점: **어떤 정점과 어떤 정점이 연결되어 있는지** 빠르게 확인 가능
- O(1), 즉 **상수 시간**에 해결 가능

```javascript
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const MAX = 1004;
// 인접 행렬을 표시할 배열입니다.
let graph = Array(MAX)
  .fill(null)
  .map(() => Array(MAX).fill(0));
let inputLines = [];
rl.on("line", (line) => {
  inputLines.push(line);
});
rl.on("close", () => {
  // 정점과 간선의 개수를 입력 받습니다.
  const [_, M] = input[0].split(" ").map(Number);

  // 간선 정보 처리
  for (let i = 1; i <= M; i++) {
    // 간선이 연결하는 두 정점의 정보를 입력 받습니다.
    const [a, b] = inputLines[i].split(" ").map(Number);
    graph[a][b] = 1; // a -> b 간선이 존재한다는 의미입니다.
    graph[b][a] = 1; // 양방향 간선인 경우에는 b -> a 간선도 존재합니다.
  }
  console.log(graph);
});
```

#### 단점

- 주어지는 정점 개수의 제곱에 비례하는 크기의 배열을 선언해야 하므로 공간 복잡도가 너무 큼

  - 주어지는 정점의 개수가 10^5개이면, 인접 행렬의 크기는 10^10
  - `int` 자료형은 하나에 4 byte이므로, 정점의 개수가 10^5개일 때 인접 행렬을 저장하기 위해 필요한 메모리는 `4 x 10^10 byte = 40 GB`
  - 일반적으로 문제를 풀 때 허용되는 메모리가 1GB를 넘지 않는다는 것을 생각해보면, 아무때나 사용 불가능하다는 것을 알 수 있음

- 어떤 정점에 연결된 다른 정점의 정보를 알고자 할 때 다른 N개의 정점에 대해 모두 살펴봐야 한다는 점이 불편함

  - 인접한 정점의 정보를 알기 위해 O(N)의 시간을 투자해야 함
  - 단 하나의 연결된 정점을 찾기 위해 많은 시간을 투자하는 건 낭비처럼 보일 수 있음

#### 정리

- 인접 행렬은 그래프의 연결 관계를 직관적으로 나타내기는 좋지만 복잡도가 높다는 점에서 범용적으로 사용하기는 어려움
- 보통 알고리즘 문제를 해결할 때 그래프를 표현한다고 하면 인접 행렬 방식보다는 **인접 리스트**방식을 주로 사용

<br><br>

### 2.2. 인접 리스트 (adjacency List)

- 어떤 정점에서 간선으로 이동할 수 있는 정점만 관리하는 표현 방식
- 구현할 때, 정점마다 이동할 수 있는 다른 정점의 개수가 다르므로 `vector`와 같은 **동적 배열** 이용

```javascript
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let graph = {};
let input = [];
rl.on("line", (line) => {
  input.push(line);
});

rl.on("close", () => {
  // 정점과 간선의 개수를 입력 받습니다.
  const [_, M] = input[0].split(" ").map(Number);

  // 간선 정보 처리
  for (let i = 1; i <= M; i++) {
    const [a, b] = input[i].split(" ").map(Number);
    // 객체의 Key가 없다면 초기화 해준다.
    if (!graph[a]) {
      graph[a] = [];
    }
    if (!graph[b]) {
      graph[b] = [];
    }
    graph[a].push(b);
    graph[b].push(a);
  }
  console.log(graph);
});
```

#### 장점

- 각 정점마다 실제로 연결되어 있는 정점의 정보만을 저장하기 때문에 공간 복잡도 측면에서 효율적
- 실제로 어떤 정점이 연결되어 있는지를 찾기 위해서 N개의 정점을 모두 확인해보지 않아도 됨

#### 단점

- 어떤 두 정점을 연결하는 간선이 존재하는지를 빠르게 확인할 수 없음

#### 정리

- 인접 행렬과 비교했을 때, 인접 리스트가 가지는 장점이 그래프 문제를 푸는 대부분의 경우에서 훨씬 강력함

<br><br>

## 3. 그래프 탐색

- 간선을 따라서 그래프의 모든 정점을 방문하는 과정
- 다음에 방문할 정점의 순서를 어떻게 정하느냐에 따라서 다양한 그래프 탐색 방법이 있을 수 있지만, 대표적인 그래프 탐색 방법에는 **DFS**와 **BFS**가 있음
