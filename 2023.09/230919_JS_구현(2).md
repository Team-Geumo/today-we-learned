# 구현(Implementation)

## 1. 아이디어를 코드로 바꾸는 구현

### 1.2. 상하좌우

### 내 풀이

```javascript
let input = require("fs").readFileSync("example.txt").toString().split("\n");

let N = Number(input[0]); // 공간의 크기
let plan = input[1].split(" "); // 이동할 계획서
let directions = { L: [0, -1], R: [0, 1], U: [-1, 0], D: [1, 0] }; // 문자별 좌표 이동

let [x, y] = [1, 1]; // 시작 좌표

// 이동 계획 하나씩 확인
for (let i = 0; i < plan.length; i++) {
  const [dx, dy] = directions[plan[i]];
  // 이동 후 좌표 구하기
  let nx = x + dx;
  let ny = y + dy;
  // 범위 내에 위치해 있는 경우
  if (nx > 0 && nx <= N && ny > 0 && ny <= N) {
    x = nx;
    y = ny;
  }
}

console.log(`${x} ${y}`);
```

<br>

#### 해설

- 요구사항대로 구현하면 연산 횟수는 이동 횟수에 비례
- 일련의 명령에 따라서 개체를 차례대로 이동시킨다는 점에서 시뮬레이션(Simulation) 유형으로 분류되면 구현이 중요한 대표적인 문제 유형

<br><br>

### 1.3. 시각

#### 내 풀이

```javascript
let input = require("fs").readFileSync("example.txt").toString();

let N = Number(input);

let count = 0;
for (let i = 0; i <= N; i++) {
  for (let j = 0; j < 60; j++) {
    for (let k = 0; k < 60; k++) {
      const time = i.toString() + j.toString() + k.toString();
      // 매 시간 안에 '3'이 포함되어 있는지 체크
      if (time.includes("3")) count++;
    }
  }
}

console.log(count);
```

<br>

#### 해설

- 단순히 시각을 1씩 증가시키면서 3이 하나라도 포함되어 있는지 확인
- 전체 시, 분, 초에 대한 경우의 수는 24 x 60 x 60이며 3중 반복문을 이용해 계산 가능
- 이런 유형은 **완전 탐색(Brute Forcing)** 유형으로 분류되기도 함
  - 완전 탐색 알고리즘: 가능한 경우의 수를 모두 검사해보는 탐색 방법
  - 일반적으로 비효율적인 시간 복잡도를 가지고 있으므로 데이터 개수가 큰 경우에 정상적으로 동작하지 않을 수 있음
  - **확인(탐색)해야 할 전체 데이터의 개수가 100만 개 이하일 때 완전 탐색 사용하면 적절함**

<br><br>

## 2. 왕실의 나이트

### 내 풀이

- 입력 값이 하나라서 모든 경우를 체크할 수 있도록 단순하게 코드를 작성함

```javascript
const input = require("fs").readFileSync("example.txt").toString();

const direction = input.split("");
const col = { a: 0, b: 1, c: 2, d: 3, e: 4, f: 5, g: 6, h: 7 };
const x = direction[1] - 1;
const y = col[direction[0]];
let count = 0;

// 왼쪽으로 두 칸 이동 가능여부 체크
if (x - 2 >= 0) {
  if (y - 1 >= 0) count++;
  if (y + 1 < 8) count++;
}

// 오른쪽으로 두 칸 이동 가능여부 체크
if (x + 2 < 8) {
  if (y - 1 >= 0) count++;
  if (y + 1 < 8) count++;
}

// 위로 두 칸 이동 가능여부 체크
if (y - 2 >= 0) {
  if (x - 1 >= 0) count++;
  if (x + 1 < 8) count++;
}

// 아래로 두 칸 이동 가능여부 체크
if (y + 2 < 8) {
  if (x - 1 >= 0) count++;
  if (x + 1 < 8) count++;
}

console.log(count);
```

<br>

### 해설

- 나이트가 이동할 수 있는 경로를 하나씩 확인하여, 8 x 8 좌표 평면을 벗어나지 않는지 검사하며 이동
- 나이트의 현재 위치가 주어지면 현재 위치에서 이동 경로를 더한 다음, 8 x 8 좌표 평면에 있는지 확인, 반복문으로 처리

```javascript
let input = require("fs").readFileSync("example.txt").toString();

const colArr = { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 8 };
const row = Number(input[1]);
const column = colArr[input[0]];

// 나이트가 이동할 수 있는 8가지 방향 정의
const steps = [
  [-2, -1],
  [-1, -2],
  [1, -2],
  [2, -1],
  [2, 1],
  [1, 2],
  [-1, 2],
  [-2, 1],
];

// 8가지 방향에 대하여 각 위치로 이동이 가능한지 확인
let result = 0;
for (let step of steps) {
  // 이동하고자 하는 위치 확인
  nextRow = row + step[0];
  nextColumn = column + step[1];
  // 해당 위치로 이동이 가능하다면 카운트 증가
  if (nextRow >= 1 && nextRow <= 8 && nextColumn >= 1 && nextColumn <= 8) {
    result += 1;
  }
}

console.log(result);
```

<br><br>

## 3. 게임 개발

### 내 풀이

```javascript

```

<br>

### 해설

```javascript

```
