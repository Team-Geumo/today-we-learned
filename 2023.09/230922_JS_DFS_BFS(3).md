# DFS/BFS (3)

## 2. 탐색 알고리즘

### 2.1. DFS(Depth-First Search)

- **깊이 우선 탐색**
- **그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘**

<br>

#### 그래프(Graph)

- **노드(Node)** 와 **간선(Edge)** 으로 표현됨

  - 노드 = **정점(Vertex)**

- 그래프 탐색: 하나의 노드를 시작으로 다수의 노드를 방문하는 것
- 두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다(Adjacent)'라고 표현
- 프로그래밍에서 그래프는 크게 2가지 방식으로 표현 가능

  - 인접 행렬(Adjacency Matrix)
  - 인접 리스트(Adjacency List)

<br>

#### 인접 행렬(Adjacency Matrix) 방식

- 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
- 연결되어 있지 않은 노드끼리는 무한(infinity)의 비용이라고 작성

```javascript
// 인접 행렬 방식 예제

const INF = 999999999; // 무한의 비용 선언

// 2차원 리스트를 이용해 인접 행렬 표현
const graph = [
  [0, 7, 5],
  [7, 0, INF],
  [5, INF, 0],
];

console.log(graph);
```

```bash
[[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]
```

<br>

#### 인접 리스트(Adjacency List) 방식

- 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
- '연결 리스트'라는 자료구조를 이용해 구현
- JavaScript에서 그래프를 표현한다고 하면 인접 행렬 방식보다는 인접 리스트방식을 주로 사용

```javascript
// 인접 리스트 방식 예제

let graph = {};

graph[0] = [1, 2];
graph[1] = [0, 7];
graph[2] = [0, 5];
graph[5] = [2];
graph[7] = [0];

console.log(graph);
```

```bash
{0: [1, 2], 1: [0, 7], 2: [0, 5], 5: [2], 7: [0]}
```

<br>

#### DFS

- 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘
- 스택 자료구조를 이용
- 동작 과정
  - 탐색 시작 노드를 스택에 삽입하고 방문 처리
  - 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드 꺼내기
  - 위의 과정을 더 이상 수행할 수 없을 때까지 반복

```javascript
// DFS 예제

function dfs(graph, v, visited) {
  // 현재 노드 방문 처리
  visited[v] = true;
  console.log(v);
  // 현재 노드와 연결된 다른 노드를 재귀적으로 방문
  for (let i of graph[v]) {
    if (!visited[i]) {
      dfs(graph, i, visited);
    }
  }
}

// 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
const graph = {
  1: [2, 3, 8],
  2: [1, 7],
  3: [1, 4, 5],
  4: [3, 5],
  5: [3, 4],
  6: [7],
  7: [2, 6, 8],
  8: [1, 7],
};

// 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
let visited = Array(9).fill(false);

// 정의된 DFS 함수 호출
dfs(graph, 1, visited);
```

```bash
1 2 7 6 8 3 4 5
```
