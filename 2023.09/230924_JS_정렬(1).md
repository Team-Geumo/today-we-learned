# 정렬 (1)

## 1. 기준에 따라 데이터를 정렬

### 1.1. 정렬 알고리즘 개요

- **정렬(Sorting)**: **데이터를 특정한 기준에 따라서 순서대로 나열**하는 것
- 정렬부터 공부하면 '알고리즘의 효율성'을 쉽게 이해 가능
- 숫자가 하나씩 적힌 카드 10장을 오름차순으로 정렬하기
  - 우리의 뇌는 데이터의 규칙성을 파악하여, 카드를 빠르게 훑고 숫자가 0부터 9까지 구성된걸 눈치챈 다음 카드를 0부터 9까지 순차적으로 나열한 것
  - 컴퓨터는 인간과 다르게 데이터의 규칙성을 직관적으로 알 수 없으며, 어떻게 정렬을 수행할지에 대한 과정을 소스코드로 작성하여 구체적으로 명시해야 함

<br><br>

### 1.2. 선택 정렬(Selection Sort)

- 가장 원시적인 방법으로 매번 '가장 작은 것을 선택'한다는 의미
- **여러 개의 데이터 중 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정 반복**
- 가장 작은 데이터를 앞으로 보내는 과정을 `N-1`번 반복하면 정렬이 완료됨

```javascript
// 선택 정렬 소스코드

let array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];

for (let i = 0; i < array.length; i++) {
  let min_index = i; // 가장 작은 원소의 인덱스
  for (let j = i + 1; j < array.length; j++) {
    if (array[min_index] > array[j]) {
      min_index = j;
    }
  }

  [array[i], array[min_index]] = [array[min_index], array[i]]; // 구조분해 할당으로 스와핑
}

console.log(array);
```

```bash
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

- 스와프(Swap): 특정한 리스트가 주여졌을 때 두 변수의 위치를 변경하는 작업

<br>

#### 1.2.1. 선택 정렬의 시간 복잡도

- 빅오 표기법 -> **O(N^2)**
- 선택 정렬은 매우 비효율적
- 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에 잦으므로 선택 정렬 소스코드 형태에 익숙해질 필요 있음

<br><br>

### 1.3. 삽입 정렬(Insertion Sort)

- 특정한 데이터를 적절한 위치에 '삽입'
- 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정
- **정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입됨**
- 동작 원리를 직관적으로 이해하기 쉬운 알고리즘
- 선택 정렬에 비해 구현 난이도가 높은 편이지만 서낵 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘
- 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적
- 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문에, 두 번째 데이터부터 시작

<br>

- 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있음
- 특정한 데이터가 삽입될 위치를 선정할 때(삽입될 위치를 찾기 위하여 왼쪽으로 한 칸씩 이동할 때), 삽입될 데이터보다 작은 데이터를 만나면 그 위치에 멈추면 됨

```javascript
// 삽입 정렬 소스코드

let array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];

for (let i = 1; i < array.length; i++) {
  // 인덱스 i부터 1까지 감소하며 반복하는 문법
  for (let j = i; j > 0; j--) {
    // 한 칸씩 왼쪽으로 이동
    if (array[j] < array[j - 1]) {
      [array[j], array[j - 1]] = [array[j - 1], array[j]];
    }

    // 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
    else break;
  }
}

console.log(array);
```

<br>

#### 1.3.1. 삽입 정렬의 시간 복잡도

- **O(N^2)**
- 실제 수행 시간을 테스트해보면 선택 정렬과 흡사한 시간이 소요되는 것을 알 수 있음
- **삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작함**
- 최선의 경우 **O(N)** 의 시간 복잡도 가짐

<br><br>

### 1.4. 퀵 정렬(Quick Sort)

- 지금까지 배운 정렬 알고리즘 중에 가장 빨리 사용되는 알고리즘
- **기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작**
- 피벗(Pivot): 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 표현
- 퀵 정렬을 수행하기 전에 피벗을 어떻게 설정할 것인지 미리 명시해야 함
- **호어 분할(Hoare Partition) 방식**

  - 리스트에서 첫 번째 데이터를 피벗으로 정함
  - 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터 찾기
  - 큰 데이터와 작은 데이터의 위치를 서로 교환함
  - 이 과정을 반복하면 '피벗'에 대하여 정렬이 수행됨

<br>

- 피벗을 기준으로 큰 데이터와 작은 데이터를 찾는 과정에서 두 값이 엇갈린 경우, '작은 데이터'와 피벗'의 위치를 서로 변경함
- **분할(Divide)** 혹은 **파티션(Partition)**: 피벗의 왼쪽에는 피벗보다 작은 데이터가 위치하고, 피벗의 오른쪽에는 피벗보다 큰 데이터가 위치하도록 하는 작업
- 왼쪽 리스트와 오른쪽 리스트에서도 각각 피벗을 설정하여 동일한 방식으로 정렬을 수행하면 전체 리스트에 대하여 모두 정렬이 이루어짐

<br>

- 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후에, 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬을 수행함
- 재귀 함수 형태로 작성했을 때 매우 간결해짐
  - 종료 조건: 현재 리스트의 데이터의 개수가 1개인 경우

```javascript
// 퀵 정렬 소스코드

let array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8];

function quickSort(array, start, end) {
  // 원소가 1개인 경우 종료
  if (start >= end) return;

  // 피벗은 첫 번째 원소
  let pivot = start;
  let left = start + 1;
  let right = end;

  while (left <= right) {
    // 피벗보다 큰 데이터를 찾을 때까지 반복
    while (left <= end && array[left] <= array[pivot]) left += 1;

    // 피벗보다 작은 데이터를 찾을 때까지 반복
    while (right > start && array[right] >= array[pivot]) right += 1;

    // 엇갈렸다면 작은 데이터와 피벗을 교체
    if (left > right) {
      [array[right], array[pivot]] = [array[pivot], array[right]];
    }
    // 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
    else [array[left], array[right]] = [array[right], array[left]];
  }

  // 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
  quickSort(array, start, right - 1);
  quickSort(array, right + 1, end);
}

quickSort(array, 0, array.length - 1);
console.log(array);
```

```bash
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

<br>

```javascript
// 더 직관적이고 기억하기 쉬운 퀵 정렬 소스코드

let array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8];

function quickSort(array) {
  // 리스트가 하나 이하의 원소만을 담고 있다면 종료
  if (array.length <= 1) {
    return array;
  }

  const pivot = array[0]; // 피벗은 첫 번째 원소
  const tail = array.sort(1); // 피벗을 제외한 리스트

  const leftSide = array.filter((e) => e <= pivot); // 분할된 왼쪽 부분
  const rightSide = array.filter((e) => e > pivot); // 분할된 오른쪽 부분

  // 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
  return [...quickSort(leftSide), pivot, ...quickSort(rightSide)];
}

console.log(quickSort(array));
```

```bash
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

<br>

#### 1.4.1. 퀵 정렬의 시간 복잡도

- 평균적으로 **O(NlogN)**
- 최악의 경우 **O(N^2)**
- '이미 데이터가 정렬되어 있는 경우'에 매우 느리게 동작

<br><br>

### 1.5. 계수 정렬(Count Sort)

- **특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘**
- 매우 빠르게 동작할 뿐만 아니라 원리 또한 매우 간단함
- '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용 가능
- 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬 사용할 수 X
- 계수 정렬을 이용할 때는 '모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언'해야 하기 때문
- 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식(비교 기반의 정렬 알고리즘) X
- 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담음

<br>

- 먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트 생성
- 처음에는 리스트의 모든 데이터가 0이 되도록 초기화
- 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면 계수 정렬이 완료됨
- 리스트에는 각 데이터가 몇 번 등장했는지 그 횟수가 기록됨
- 리스트에 저장된 데이터 자체가 정렬된 형태 그 자체라고 할 수 있음

```javascript
// 계수 정렬 소스코드

// 모든 원소의 값이 0보다 크거나 같다고 가정
const array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2];
// 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
let count = new Array(Math.max(...array) + 1).fill(0);
let output = "";

for (let i = 0; i < array.length; i++) {
  count[array[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가
}

// 리스트에 기록된 정렬 정보 확인
for (let i = 0; i < count.length; i++) {
  for (let j = 0; j < count[i]; i++) {
    output += i + " ";
  }
}

console.log(output.trim());
```

```bash
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
```

<br>

#### 1.5.1. 계수 정렬의 시간 복잡도

- 모든 데이터가 양의 정수인 상황에서 데이터의 개수를 `N`, 데이터 중 최대값의 크기를 `K`라고 할 때, 계수 정렬의 시간 복잡도는 **O(N + K)**
- 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야 하기 때문
- 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작함

<br>

#### 1.5.2. 계수 정렬의 공간 복잡도

- 때에 따라서 심각한 비효율성을 초래할 수 있음
  - 데이터가 `0`과 `999999`, 단 2개만 존재할 때에도 리스트의 크기가 100만 개가 되도록 선언해야 함
- 항상 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합함
- **데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수 없음**
