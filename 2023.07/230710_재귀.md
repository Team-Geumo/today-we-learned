# 재귀
## 귀납적 사고
### 재귀 알고리즘이란
- 하나의 함수에서 자기 자신을 다시 호출하여 작업을 수행하는 알고리즘
- 재귀로 문제를 풀이하기 위해 가장 중요한 점은 우리가 평소에 생각해 오던 절차 지향적 사고를 버리고 귀납적 사고를 통해 문제에 접근해야 함

### 절차 지향적 사고와 귀납적 사고
- ex) 도미노 n개가 나열되어 있는 상황

**1. 절차 지향적 사고**
- 1번 도미노를 쓰러뜨리면 2번 도미노가 쓰러지고 2번 도미노가 쓰러지면 3번 도미노가 쓰러짐
- 위와 같이 연이어 모든 n개의 도미노가 쓰러지게 될 것임

**2. 귀납적 사고**
- 1번 도미노가 쓰러짐
- 1번 도미노가 쓰러지는것은 매우 자명하고, k번 도미노가 쓰러지면 k+1번째 도미노 또한 쓰러짐
- 따라서 결국은 모든 도미노가 쓰러지게 될 것임
- 재귀 알고리즘을 이용해 알고리즘 문제 풀이를 하는 동안은 앞에서 강조했듯이, 절차 지향적 사고를 버려야 함

## 재귀 함수의 특성
### 1. base condition
- 재귀 함수는 특정 입력에 대해서 자기 자신을 호출하지 않고 종료해야 함
- 또한 모든 입력은 base condition으로 수렴 해야 함
- 이를 지키지 않으면 재귀함수는 무한루프에 빠져 에러를 발생시킴 

### 2. 함수를 명확하게 정의하자
- 재귀함수를 만들때는 함수를 명확하게 정의해야 함
- 함수의 인자로 어떤 것을 받을지 / 어디까지 계산한 후 자기 자신에게 넘겨줄 지를 명확하게 정의해야 함

 
### 3. 재귀함수와 반복문
- 모든 재귀함수는 재귀구조 없이 반복문 만으로 동일 동작을 수행하는 함수를 구현할 수 있음
- 재귀를 적절하게 잘 사용하면 코드가 간결해 진다는 장점이 있지만, 메모리와 시간적 측면에서는 어느정도 손해를 보게 됨
- 따라서 반복문으로도 간단하게 해결 가능한 문제라면 반복문을 사용해 구현하고, 반복문 만으로는 너무 코드가 복잡해 질 것 같다면 재귀 구조를 사용하는 것이 좋음

- ex) 재귀함수와 피보나치 수열
- 다음 코드는 n의 값이 커질수록 연산의 처리량이 지수함수 형태로 매우 가파르게 늘어남
```java
int fibo(int n){
	if(n == 1) return 1; // base condition
	return fibo(n-1) + fibo(n-2);
}
```
- fibo(5)를 호출하는 경우 : fibo(4)와 fibo(3)이 호출됨. fibo(4)를 호출하면 fibo(3)과 fibo(2)가 호출됨. fibo(3)을 호출하면 fibo(2)와 fibo(1)이 호출된다 fibo(2)를 호출하면 fibo(1)과 fibo(1)이 호출됨.
- 위 과정을 자세히 살펴보면 이미 한 번 호출된 함수가 또 다시 호출되는 케이스가 빈번하게 발생하고 있음
- 자기 자신의 호출을 계속하다 보니 시간 복잡도가 예상과 달리 급격하게 늘어나게 됨
- 따라서 이렇게 한 함수가 자기 자신을 여러번 호출하는 케이스는 재귀 호출 보다는 작은 문제의 답으로 큰 문제의 답을 풀어내는 다이나믹 프로그래밍(Dynamic Programming) 알고리즘을 사용해 문제를 풀이하는 것이 바람직함
