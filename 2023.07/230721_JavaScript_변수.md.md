# 04장 변수
## 4.1 변수란 무엇인가? 왜 필요한가?

**자바스크립트의 연산 과정**
```js
10 + 20
```
1. `10`, `20`, `+`라는 리터럴(literal)과 연산자(operator)의 의미를 알고있어야 함
2. `10 + 20`이라는 표현식(expression)의 의미도 해석(parsing)할 수 있어야 함

**메모리(memory)**
- 데이터를 저장할 수 있는 메모리 셀(memory cell)의 집합체
- 메모리 셀 하나의 크기는 **1바이트(8비트)**
- 컴퓨터는 메모리 셀(1바이트) 단위로 데이터를 저장하거나 읽음
- 각 셀은 고유의 **메모리 주소(memory address)** 를 가짐
- 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해 메모리의 크기 만큼 정수로 표현됨
- 컴퓨터는 모든 데이터를 2진수로 처리함

**CPU와 메모리의 연산 과정**
- **메모리**는 기억하는 역할, **CPU**는 연산을 수행하는 역할
- 위 예제의 숫자 `10`, `20`은 메모리 상의 임의의 위치(메모리 주소)에 기억(저장)되고 CPU는 이 값을 읽어들여 연산을 수행
- 연산의 결과인 `30`도 메모리 상의 임의의 위치에 저장됨
- 만약 `30`을 재사용하고 싶다면 메모리 주소를 통해 메모리 공간에 직접 접근해야 하지만, 코드가 실행될 때마다 메모리 주소는 변경되므로 올바른 방법이 아님
- 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고 그 값을 읽어들여 재사용하기 위해 변수라는 메커니즘을 제공함

**변수(variable)**
- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로 값의 위치를 가리키는 상징적인 이름
- 변수는 **컴파일러** 또는 **인터프리터**에 의해 메모리 주소로 치환되어 실행되므로 직접 메모리 주소에 접근하지 않아도 안전하게 값에 접근할 수 있게 됨

```js
var result = 10 + 20;
```
- **변수 이름** : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름 (`result`)
- **변수 값** : 변수에 저장된 값 (`30`)
- **할당(assignment)** : 변수에 값을 저장하는 것
- **참조(reference)** : 저장된 값을 읽어들이는 것

## 4.2 식별자
**식별자**
- 메모리 상에 존재하는 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 식별자는 어떤 값이 저장되어있는 메모리 주소를 기억(저장)해야 함
- 변수, 함수, 클래스 등
- 네이밍 규칙을 준수해야 하며, **선언(declaration)** 에 의해 자바스크립트 엔진에 식별자의 존재를 알림
- 모든 식별자는 **실행 컨텍스트**에 저장됨

**실행 컨텍스트**
- 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
- 자바스크립트 엔진은 실행 컨텍스트를 통해 **식별자**와 **스코프**를 관리함
- 변수 이름과 변수 값은 실행 컨텍스트 내에 **키(key)-값(value)** 형식인 객체로 등록되어 관리됨
- 변수 관리 메커니즘 : [**13장 스코프**](), [**23장 실행 컨텍스트**]() 참고

**참조 에러(reference Error)**
- 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러
- 선언하지 않은 식별자에 접근할 때 나타남

## 4.3 변수 선언
**변수 선언(variable declaration)**
- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해 값을 저장할 수 있게 준비하는 것
- 변수를 사용하기 위해선 반드시 선언이 필요함
- 자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행
    1. **선언 단계** : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
    2. **초기화 단계** : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화 함
- **키워드** : `var`, `let`, `const`

**var**
- 새로운 변수를 선언할 것을 지시하는 키워드
- `var` 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 일어남

## 4.4 변수 선언의 실행 시점과 호이스팅
```js
console.log(score); // undefined

var score;
```
변수 선언이 소스코드가 한 줄씩 실행되는 시점, 즉 런타임(runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문에 참조 에러가 발생하지 않음

**호이스팅(hoisting)**
- 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 전에 소스코드 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 함
- 소스 코드 평가 과정에서 자바스크립트 엔진은 모든 **선언문**을 코드에서 찾아내 **먼저 실행함**
- 평가 과정이 끝나면 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행

## 4.5 값의 할당
```js
console.log(score); // undefined

// var score;
// score = 80;
var score = 80;

console.log(score); // 80
```
자바스크립트 엔진은 변수 선언과 값의 할당의 실행 시점이 다름
- 변수 선언은 런타임 시점 이전에 먼저 실행, 값의 할당은 런타임에 실행
- 값을 할당할 때는 이전 값 `undefined`가 저장되어 있던 메모리 공간에 할당 값 `80`을 새롭게 저장하는 것이 아니라 새로운 메모리 공간에 할당 값 `80`을 저장함

## 4.6 값의 재할당
```js
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```
var 키워드로 선언한 변수는 값을 재할당할 수 있음
- 변수에 값을 재할당하면 처음 값을 할당했을 때와 마찬가지로 새로운 메모리 공간을 확보한 후 그 공간에 `90`을 저장함
- `score` 변수의 이전 값인 `undefined`, `80`은 어떤 식별자와도 연결되어있지 않음. 이렇게 불필요한 값들은 **가비지 콜렉터**에 의해 메모리에서 자동 해제됨 (시점은 알 수 없음)
- 만약 값을 재할당 할 수 없으면 **상수(constant)** 라고 함

**가비지 콜렉터(garbage collector)**
- 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능
- 자바스크립트느 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 **메모리 누수(memory link)** 를 방지함

**언매니지드 언어(unmanaged language)와 매니지드 언어(managed language)**
- 프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지드 언어로 분류
- **언매니지즈 언어** : 개발자가 메모리 제어를 주도할 수 있음
- **매니지드 언어** : 메모리 관리 기능을 언어 차원에서 담당함

## 4.7 식별자 네이밍 규칙
**자바스크립트의 네이밍 규칙**
- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있음
- 단, 식별자는 숫자로 시작하는 것을 허용하지 않음
- ES5부터 식별자를 만들 때 유니코드 문자를 허용하므로 알파벳 외의 한글이나 일본어 식별자도 사용할 수 있으나 권장하지 않음
- 예약어는 식별자로 사용할 수 없음

**자바스크립트의 예약어**
  <table>
    <tr><td>await</td><td>break</td><td>case</td><td>catch</td><td>class</td><td>const</td></tr>
    <tr><td>continue</td><td>debugger</td><td>default</td><td>delete</td><td>do</td><td>else</td></tr>
    <tr><td>enum</td><td>export</td><td>extends</td><td>false</td><td>finally</td><td>for</td></tr>
    <tr><td>function</td><td>if</td><td>implements*</td><td>import</td><td>in</td><td>instanceof</td></tr>
    <tr><td>interface*</td><td>let*</td><td>new</td><td>null</td><td>package*</td><td>private*</td></tr>
    <tr><td>protected*</td><td>public*</td><td>return</td><td>super</td><td>static*</td><td>switch</td></tr>
    <tr><td>this</td><td>throw</td><td>true</td><td>try</td><td>typeof</td><td>var</td></tr>
    <tr><td>void</td><td>while</td><td>with</td><td>yield*</td><td></td><td></td></tr>
  </table>


**네이밍 컨벤션(naming convention)**
```js
var firstName; // 카멜 케이스(camelCase)
var first_name; // 스네이크 케이스(snake_case)
var FirstName; // 파스칼 케이스(PascalCase)
var strFirstName; // 헝가리언 케이스(typeHungarianCase)
```
일반적으로 변수와 함수의 이름에는 카멜 케이스, 생성자 함수와 클래스의 이름에는 파스칼 케이스를 사용함