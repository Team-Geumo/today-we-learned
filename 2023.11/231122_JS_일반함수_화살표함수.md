# 일반 함수 vs. 화살표 함수

```
✅ 일반 함수는 함수 호출 방식에 따라 this가 동적으로 결정됩니다.
함수를 생성자(constructor)로 사용할 수 있으며, 함수 실행 시 암묵적으로 arguments 객체가 전달되어 사용할 수 있습니다.
prototype 프로퍼티를 통해 객체의 프로토타입을 정의할 수 있습니다.

반면, 화살표 함수는 ES6에서 도입된 새로운 함수 정의 방식으로, function 키워드 대신 화살표(=>)를 사용하여 간결하게 함수를 정의할 수 있습니다.
화살표 함수는 prototype 프로퍼티가 없어서 생성자 함수로 사용할 수 없습니다.
또한, 화살표 함수는 arguments 객체를 생성하지 않습니다.
화살표 함수의 this는 언제나 상위 스코프의 this를 가리키며, this에 바인딩할 객체가 정적으로 결정됩니다.
```

<br>

## 1. 일반 함수

- 함수 호출방식에 따라 `this` 바인딩할 객체가 동적으로 결정됨
- `new` 키워드를 통해 `constructor` 함수로 사용 가능
- 함수 실행 시 암묵적으로 `arguments`(인수) 변수가 전달되어 사용 가능

<br>

## 2. 화살표 함수

- ES6부터 도입된 함수로 `function` 키워드 대신 화살표 `=>`를 사용해 좀 더 간략하게 함수를 정의할 수 있는 방식
- `protytype property`가 없기 때문에 `new` 키워드를 사용하여 `constructor` 함수로 사용할 수 없음
- `argument` 객체를 생성하지 않음
- 화살표 함수의 `this`는 언제나 상위 스코프의 `this`(Lexical this)를 가리키며, `this`에 바인딩할 객체가 정적으로 결정됨
