# 쿠키 vs. 세션 vs. 토큰

```
쿠키, 세션, 토큰은 모두 서버가 클라이언트 인증을 확인하는 방식입니다.

쿠키 (Cookie)
- 설명: 클라이언트 측에 쿠키를 저장하고, 이를 서버로 전송하여 인증을 확인합니다.
- 동작 원리: 서버는 클라이언트에 쿠키를 설정하고, 클라이언트는 이를 저장해두었다가 요청 시마다 해당 쿠키를 서버에 함께 전송합니다.
- 장점: 간단하고 유연하며, 상태를 유지하기 용이합니다.
- 단점: 쿠키는 클라이언트에 저장되므로 보안에 취약할 수 있습니다.

세션 (Session)
- 설명: 클라이언트와 서버 간의 대화 상태를 유지하며, 인증을 확인하는 방식입니다.
- 동작 원리: 클라이언트가 로그인하면 서버는 세션을 생성하고 세션 ID를 클라이언트에게 전달합니다. 이후의 요청은 해당 세션 ID를 통해 인증을 확인합니다.
- 장점: 보안성이 높고, 서버 측에서 세션을 관리하기 때문에 클라이언트에 저장되는 정보가 제한됩니다.
- 단점: 서버에 상태를 유지해야 하므로 확장성이 제한될 수 있습니다.

토큰 (Token)
- 설명: 클라이언트에 대한 정보를 담은 토큰을 이용하여 인증을 확인하는 방식입니다.
- 동작 원리: 클라이언트가 로그인하면 서버는 토큰을 발급하고, 클라이언트는 이를 저장하여 요청 시마다 함께 전송합니다.
- 장점: 상태를 서버에 저장하지 않아 stateless한 특성을 가지며, 확장성이 용이합니다.
- 단점: 토큰을 안전하게 다뤄야 하며, 클라이언트가 토큰을 관리해야 합니다.

쿠키는 클라이언트에 저장되어 보안에 취약하고, 세션은 서버에 저장되어 보안성이 높지만 성능 이슈가 있을 수 있습니다. 토큰은 상태를 서버에 저장하지 않고, 보안성과 확장성을 고려할 때 많이 사용됩니다.
```

<br><br>

## 1. Cookie 인증

- **Key-Value 형식의 문자열** 덩어리
- 클라이언트가 어떠한 웹사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버를 통해 **클라이언트의 브라우저에 설치되는 작은 기록 정보 파일**
- 각 사용자의 브라우저에 정보를 저장하니 고유 정보 식별 가능

<br>

### 1.1. Cookie 인증 방식

![쿠키 인증 방식](./image/cookie.png)

1. **요청 보내기**
   - 사용자가 브라우저에서 웹 사이트에 접속하면, 브라우저(클라이언트)는 해당 웹 서버에게 요청(접속)을 보냄
2. **쿠키 설정하기**
   - 서버는 클라이언트의 요청을 받고, 응답을 생성할 때 `Set-Cookie` 헤더를 사용하여 브라우저에 쿠키를 설정함
   - 이 헤더에는 클라이언트에 저장할 쿠키의 정보가 담겨 있음
     ```bash
     HTTP/1.1 200 OK
     Content-Type: text/html
     Set-Cookie: username=johndoe; expires=Wed, 30 Nov 2023 23:59:59 GMT; path=/
     ```
     - `username=johndoe`: 쿠키의 이름과 값
     - `expire`: 쿠키의 만료 날짜
     - `path`: 쿠키의 유효 경로 설정
3. **쿠키를 요청 헤더에 담아 보내기**
   - 브라우저는 해당 사이트의 모든 요청에 자동으로 쿠키를 실어서 보냄
     ```bash
     GET /some-page HTTP/1.1
     Host: example.com
     Cookie: username=johndoe
     ```
   - 서버는 클라이언트가 이전에 설정한 쿠키를 `Cookie` 헤더를 통해 받아 해당 사용자의 정보를 확인하고 세션 등의 상태를 유지함
     - 해당 요청의 클라이언트가 누군지 식별하거나 정보를 바탕으로 추천 광고를 띄움

<br>

### 1.2. Cookie 방식의 단점

- 가장 큰 단점은 **보안이 취약**하다는 점
  - 요청 시 쿠키의 값을 그대로 보내기 때문에 유출 및 조작 할당 위험 존재
- 쿠키에는 **용량 제한**이 있어 많은 정보를 담을 수 없음
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 **공유가 불가능**
- 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해짐

<br><br>

## 2. Session 인증

- 쿠키의 보안적 이슈 때문에, 세션은 비밀번호 등 클라이언트의 민감한 정보를 브라우저가 아닌 **서버 측에 저장하고 관리**
  - 서버의 메모리에 저장하기도 하고, 서버의 로컬 파일이나 데이터베이스에 저장하기도 함
- 민감한 정보는 클라이언트에 보내지 말고 서버에서 모두 관리

<br>

### 2.1. Session 인증 방식

![세션 인증 방식](./image/session.png)

1. **로그인 및 세션 생성**
   - 사용자가 웹 사이트에 로그인하면, 서버는 해당 사용자의 세션을 생성하고 세션에 필요한 정보(사용자 아이디, 권한 등)을 저장
   - 각 세션은 고유한 식별자인 **Session ID**를 부여받음
2. **세션 ID를 쿠키에 저장**
   - 서버는 클라이언트(브라우저)에게 응답을 할 때, `Set-Cookie` 헤더를 사용하여 쿠키에 **Session ID**를 저장함
     ```bash
     HTTP/1.1 200 OK
     Content-Type: text/html
     Set-Cookie: session_id=abc123; path=/; secure; HttpOnly
     ```
     - `sesson_id`: 쿠키의 이름
     - `abc123`: 세션 ID
     - `secure`: HTTPS에서만 쿠키를 전송되도록 하는 옵션
     - `HttpOnly`: JavaScript를 통한 접근을 방지하는 옵션
3. **세션 ID를 포함한 요청 전송**
   - 사용자가 다른 페이지나 리소스를 요청할 때, 브라우저는 자동으로 쿠키를 해당 도메인으로 함께 보냄
     ```bash
     GET /some-page HTTP/1.1
     Host: example.com
     Cookie: session_id=abc123
     ```
4. **세션 ID로 인증**
   - 서버는 클라이언트가 보낸 요청의 쿠키에서 Session ID를 추출함
   - 추출한 Session ID를 서버에 저장된 세션과 비교하여 사용자를 인증하고 필요한 정보를 제공
   - 사용자는 세션 ID를 통한 인증을 통해 로그인 상태를 유지하면서 웹 사이트 이용 가능

<br>

### 2.2. Session 방식의 단점

- 해커가 **Session ID 자체를 탈취**하여 클라이언트인 척 위장할 수 있다는 한계 존재
  - 쿠키를 포함한 요청이 외부에 노출되더라도 Session ID 자체는 유의미한 정보를 담고 있지 않음
  - 서버에서 IP 특정을 통해 해결할 수 있긴 함
- 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해짐

<br><br>

## 3. Token 인증

- 클라이언트가 서버에 접속하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 **토큰**을 부여
  - 토큰은 **유일**하며 토큰을 발급 받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보냄
  - 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리함
- 기존의 세션 기반 인증은 서버가 파일이나 데이터베이스에 세션 정보를 가지고 있어야 하고, 이를 **조회하는 과정**이 필요하기 때문에 많은 오버헤드 발생
  - 토큰은 세션과 달리 서버가 아닌 **클라이언트에 저장**되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담 덜 수 있음
  - 토큰 자체에 데이터가 들어있기 때문에 클라이언트에서 받아 위조되었는지 판별만 하면 되기 때문
- 토큰은 앱과 서버가 통신 및 인증할 때 가장 많이 사용
  - 웹에는 쿠키와 세션이 있지만 앱에는 없기 때문

<br>

### 3.1. Token 인증 방식

![토큰 인증 방식](./image/token.png)

1. **로그인**
   - 사용자가 아이디와 비밀번호로 로그인
   - 서버는 사용자의 인증 정보를 확인하고, 유효한 경우에는 유일한 식별자인 **토큰** 발급
2. **토큰 발급**
   - 서버는 클라이언트에게 유일한 토큰 발급
   - 토큰은 클라이언트의 로그인 상태를 나타내며, 서버는 이를 활용하여 클라이언트를 인증함
   - 예시
     ```bash
     HTTP/1.1 200 OK
     Content-Type: application/json
     {
       "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
     }
     ```
3. **토큰 저장**
   - 클라이언트는 받은 토큰을 안전한 곳에 저장
     - 주로 쿠키, 로컬 스토리지, 세션 스토리지와 같은 저장소에 저장
   - 저장된 토큰은 클라이언트의 로그인 상태를 나타냄
4. **토큰을 포함한 요청 전송**
   - 클라이언트가 서버에 요청을 보낼 때마다, 저장된 토큰을 HTTP 요청 헤더에 포함시켜 전달함
   - 예시
     ```bash
     GET /api/user/profile HTTP/1.1
     Host: example.com
     Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
     ```
5. **토큰을 검증 및 응답**
   - 서버는 클라이언트의 요청에 포함된 토큰을 검증함
     - 검증은 토큰의 유효성, 만료 여부 등을 확인하는 작업을 포함함
   - 토큰이 유효하다면, 서버는 해당 요청에 대한 응답을 생성하고 클라이언트에게 제공함
   - 서버는 DB를 조회하지 않고 토큰에 포함된 정보를 통해 클라이언트의 식별 및 권한 부여를 수행

<br>

### 3.2. 서버 기반 vs. 토큰 기반

- **서버(세션) 기반 인증 시스템** → Stateful(상태 유지)
  - 서버의 세션을 사용해 사용자 인증을 하는 방법
  - 서버 측(서버 램 or 데이터베이스)에서 사용자의 인증 정보를 관리하는 것을 의미
  - 클라이언트로부터 요청을 받으면 클라이언트의 상태를 계속해서 유지해 놓고 사용함
  - 사용자가 증가함에 따라 성능의 문제를 일으킬 수 있으며 확장성이 어렵다는 단점 가짐
- **토큰 기반 인증 시스템** → Stateless(상태 비유지)
  - 인증 받은 사용자에게 토큰을 발급하고, 로그인이 필요한 작업일 경우 헤더에 토큰을 함께 보내 인증받은 사용자인지 확임
  - 서버 기반 인증 시스템과 달리 상태를 유지하지 않으므로 Stateless한 특징 가짐

<br>

### 3.3. Token 방식의 단점

- 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있음
- Payload 자체는 암호화되지 않기 때문에 유저의 **중요한 정보는 담을 수 없음**
- 토큰을 **탈취**당하면 대처하기 어려움
  - 사용 기간 제한을 설정하는 식으로 극복함
