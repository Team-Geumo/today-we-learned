# 원시 값과 객체의 비교 (1)

**원시 타입(primitive type)과 객체 타입(object/reference type)의 차이**

- 원시 값은 **변경 불가능한 값(immutable value)** 이고, 객체는 **변경 가능한 값(mutable value)** 임
- 원시 값을 변수에 할당하면 **변수(확보된 메모리 공간)에는 실제 값이 저장되고**, 객체를 변수에 할당하면 **변수(확보된 메모리 공간)에는 참조 값이 저장됨**
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달(값에 의한 전달, pass by value)되고**, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **잠조 값이 복사되어 전달(참조에 의한 전달, pass by reference)** 됨

## 원시 값

### 변경 불가능한 값

- 원시 값은 읽기 전용(read-only) 값으로서 **변경 불가능한 값**임
- 원시 값 자체를 변경할 수 없다는 의미지 **변수 값을 변경할 수 없다는 의미가 아님**
- 원시 값은 불변성(immutability)을 가지기 때문에, 원시 값을 할당한 변수는 새로운 메모리에 새로운 원시 값을 재할당하는 것 이외에는 변수 값을 변경할 수 있는 방법이 없음

### 문자열과 불변성

- 원시 값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야함, [**6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조**]() 참고
- 원시 값인 문자열은 몇 개의 문자로 이루어졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다는 특징이 있음 (숫자 값은 크기에 상관 없이 동일하게 8바이트가 필요함)
- 이 같은 이유로 C, Java에서는 문자열 타입이 존재하지 않음 (C는 문자의 배열로 처리, Java는 String 객체로 처리)
- 자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공하며 문자열이 생성된 이후에는 변경할 수 없음
- 문자열은 **유사 배열 객체**이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있지만 값 자체를 변경할 수는 없음

```js
var str = 'string';

str[0] = 'S';
console.log(str[0]); // 각 문자에 접근할 수 있지만 값은 변경되지 않음 (에러 발생 X)
```

<br><br>

**유사 배열 객체(array-like object)** : 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 가지는 객체

```js
var str = 'string';

console.log(str[0]); // s
console.log(str.length); // 6
```

- 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동으로 변환됨, [**21.3 원시 값과 래퍼 객체**]() 참고

### 값에 의한 전달

```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

- 위 예시처럼 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(`copy`)는 **할당되는 변수(`score`)의 원시값이 복사되어 전달됨 (값에 의한 전달)**
- `score` 변수와 `copy` 변수의 값 80은 서로 다른 메모리 공간에 저장된 별개의 값이며, `score` 변수의 값을 변경해도 `copy` 변수에 어떤 영향도 주지 않음
- 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되는 것임. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음
- 핵심은 **두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어** 어느 한 쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것
