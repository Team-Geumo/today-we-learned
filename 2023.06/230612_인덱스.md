### 인덱스

- B-트리
  
  - 인덱스는 B-트리로 이루어져 있음
  
  - B-트리
    
    - 이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 벨런스를 맞추는 트리
    
    - 루트 노드, 리프 노드, 브랜치 노드로 나뉨
    
    - 정렬된 순서를 보장하고, 멀티레벨 인덱싱을 통한 빠른 검색 가능
    
    - 자료구조에서 자세히...

- 인덱스가 효율적인 이유
  
  - 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리 구조와 트리 깊이의 대수확장성
    
    - 대수확장성
      
      - 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
      
      - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가
        
        - 트리 깊이가 3인 경우 인덱스 항목의 수는 64

- 인덱스 만드는 방법
  
  - 데이터베이스마다 다름
  
  - MySQL
    
    - 클러스터형 인덱스
      
      - 테이블 당 하나 설정
    
    - 세컨더리 인덱스
      
      - 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
  
  - MongoDB
    
    - 도큐먼트를 만들면 자동으로 ObjectID가 형성되며 해당 키가 기본키
    
    - 세컨더리키를 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있음

- 인덱스 최적화 기법
  
  - 인덱스는 비용
    
    - 인덱스는 두 번 탐색하도록 강요
      
      - 인덱스 리스트, 컬렉션 순으로 탐색하기 때문
      
      - 이 과정에서 비용이 들게 됨
    
    - 컬렉션이 수정되었을 때 인덱스 수정이 필요
      
      - 이 과정에서도 비용이 듦
    
    - 이 모든 과정이 비용이기 때문에 쿼리에 있는 필드에 인덱스를 다 설정하는 것이 최적이 아님
    
    - 또한 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적
  
  - 테스팅 하기
  
  - 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순서