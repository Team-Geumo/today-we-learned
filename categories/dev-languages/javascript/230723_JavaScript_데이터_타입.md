# 06장 데이터 타입
**자바스크립트(ES6)의 데이터 타입**

자바스크립트의 8개의 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 분류
<table>
  <tr>
    <th>구분</th>
    <th>데이터 타입</th>
    <th>설명</th>
  </tr>
  <tr>
    <td rowspan="7">원시 타입</td>
    <td>숫자(<code>Number</code>) 타입</td>
    <td>숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재</td>
  </tr>
  <tr>
    <td>문자열(<code>String</code>) 타입</td>
    <td>문자열</td>
  </tr>
  <tr>
    <td>불리언(<code>Boolean</code>) 타입</td>
    <td>논리적 참(<code>true</code>)과 거짓(<code>false</code>)</td>
  </tr>
  <tr>
    <td><code>Undefined</code> 타입</td>
    <td>var 키워드로 선언된 변수에 암묵적으로 할당되는 값</td>
  </tr>
  <tr>
    <td><code>Null</code> 타입</td>
    <td>값이 없다는 것을 의도적으로 명시할 때 사용하는 값</td>
  </tr>
  <tr>
    <td>심벌(<code>Symbol</code>) 타입</td>
    <td>고유하고 변경 불가능한 원시 타입, ES6에서 추가됨</td>
  </tr>
  <tr>
    <td>빅인트(<code>BigInt</code>) 타입</td>
    <td>2^53-1보다 큰 정수를 표현할 수 있는 새로운 원시 타입, ES11에서 추가됨</td>
  </tr>
  <tr>
    <td colspan="2">객체 타입</td>
    <td>객체, 함수, 배열 등</td>
  </tr>
</table>

## 6.1 숫자 타입
자바스크립트에서 숫자 타입의 값은 모두 배정밀도 64비트 부동소수점 형식을 따름<br>
모든 수를 **10진수 실수**로 처리하며 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않음<br>
```js
var binary = 0b01000001;
var octal = 0o101;
var hex = 0x41;

console.log(binary); // 65
console.log(octal);  // 65
console.log(hex);    // 65
console.log(binary === octal); // true
console.log(octal === hex);    // true
```

**특별한 숫자 타입**
- **`Infinity`** : 양의 무한대
- **`-Infinity`** : 음의 무한대
- **`NaN`** : 산술 연산 불가(not-a-number)

## 6.2 문자열 타입
0개 이상의 16비트 유니코드 문자(UTF-16)의 집합<br>
자바스크립트에서 문자열은 원시타입이며 변경 불가능한 값<br>
- 작은 따옴표(`''`), 큰 따옴표(`""`) 또는 백틱(<code>``</code>)으로 감싸며 일반적으로 작은 따옴표를 사용함

  ```js
  var string;
  string = '문자열';
  string = "문자열";
  string = `문자열`;
  ```

## 6.3 템플릿 리터럴(template literal)
멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공<br>
런타임에 일반 문자열로 변환되어 처리됨

**표현법**

일반적인 따옴표 (`''`, `""`) 대신 백틱(<code>``</code>)을 사용해 표현
```js
var template = `Template literal`;
console.log(template); // Template literal
```

### 6.3.1 멀티라인 문자열(multi-line string)
**일반 문자열**

일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않으므로 백슬래시(`\`)로 시작하는 **이스케이프 시퀀스(escape sequence)**를 사용해야 함
```js
var template = `<ul>\n\t<li><a href="#">Home</li>\n</ul>`;
```

|이스케이프 시퀀스|의미|
|---|---|
|`\0`|Null|
|`\b`|백스페이스|
|`\f`|폼 피드(Form Feed) : 크린터로 출력할 경우 다음 페이지의 시작점으로 이동|
|`\n`|개행(LF, Line Feed) : 다음 행으로 이동|
|`\r`|개행(CR, Carriage Return) : 커서를 처음으로 이동|
|`\t`|탭(수평)|
|`\v`|탭(수직)|
|`\uXXXX`|유니코드, ex) `\u0041`은 A|
|`\'`|작은 따옴표|
|`\"`|큰 따옴표|
|`\\`|백슬래시|

**라인 피드와 캐리지 리턴**
- **라인 피드(LF, Line Feed)** : 커서를 정지한 상태에서 종이를 한 줄 올리는 것
- **캐리지 리턴(CR, Carriage Return)** : 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것
- 초창기 컴퓨터는 출력을 프린터로 수행해 CRLF를 모두 사용함
- 현재 컴퓨터 운영체제는 서로 다른 개행 방식을 사용함
  1. **Windows** : CRLF 사용
  2. **UNIX** : LF 사용
  3. **macOS** : v10부터 LF 사용
<br><br>
<hr>
<br>

**템플릿 리터럴**

템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며 모든 공백이 있는 그대로 적용됨
```js
var template = `<ul>
  <li><a href="#">Home</li>
</ul>`;

console.log(template);
// <ul>
//   <li><a href="#">Home</li>
// <ul>
```

### 6.3.2 표현식 삽입
템플릿 리터럴 내에서 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있음<br>
이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 강제 변환되어 삽입됨
```js
console.log(`1 + 2 = ${1 + 2}`) // 1 + 2 = 3
```

## 6.4 불리언 타입
불리언 타입의 값은 논리적 참, 거짓을 나타내는 `true`와 `false`만 존재함

## 6.5 undefined 타입
자바스크립트 엔진이 **변수를 초기화** 할 때 사용하는 값<br>
`undefined`를 개발자가 의도적으로 변수에 할당한다면 혼란을 줄 수 있으므로 권장하지 않음
- `var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화 됨

## 6.6 null 타입
변수에 값이 없다는 것을 **의도적으로 명시**할 때 사용<br>
변수에 `null`을 할당하는 것은 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미
- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환하기도 함
- ex) `document.querySelector`에서 조건에 부합하는 HTML 요소를 찾을 수 없을 때 에러 대신 null을 반환함
  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <script>
      var element = document.querySelector('.myClass');
      console.log(element); // null
    </script>
  </body>
  </html>
  ```

## 6.7 심벌 타입
변경 불가능한 원시 타입의 값으로 다른 값과 중복되지 않는 유일무이한 값<br>
ES6에서 추가된 자바스크립트 7번째 타입<br>
- 심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 `Symbol` 함수를 호출해 생성함
- 생성된 심벌 값은 외부에 노출되지 않음
- 심벌 더 알아보기 : [**33장 7번째 타입 Symbol**]() 참고

```js
var key = Symbol('key');
console.log(typeof key); // symbol

var obj = {};
obj[key] = 'value';
```

## 6.8 객체 타입
자바스크립트는 객체 기반 언어이며, **자바스크립트를 이루고 있는 거의 모든 것은 객체임**<br>
6개 타입(`Number`, `String`, `Boolean`, `Undefined`, `Null`, `Symbol`) 이외의 값은 모두 객체 타입<br>
- 원시 타입과 객체 타입의 차이 : [**11장 원시 값과 객체의 비교**]() 참고

## 6.9 데이터 타입의 필요성
### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조
메모리에 값을 저장하려면 확보해야 할 메모리 공간의 크기를 결정해야 함<br>
자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보함<br>

```js
var score = 100;
```
<br>

**메모리에 값을 저장할 때**

- 위 코드가 실행되면 컴퓨터는 먼저 숫자 값 `100`을 저장하기 위해 숫자 타입의 메모리 공간(8바이트)을 확보함
- 확보된 메모리에 숫자 값 `100`을 2진수로 저장함


**메모리에서 값을 참조할 때**

- 식별자 `score`을 통해 메모리 공간의 주소를 찾아갈 수 있음<br>
- 이 때, 한 번에 읽어 들여야 할 메모리 셀의 크기는 데이터 타입에 의해 결정됨

### 6.9.2 데이터 타입에 의한 값의 해석
모든 값은 메모리에 **2진수**, 즉 비트의 나열로 저장됨<br>
- 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석됨
- ex) 메모리에 저장된 `0100 0001`은 숫자 타입일 때 `65`, 문자열 타입일 때 `A`로 해석됨

<br>

**데이터 타입이 필요한 이유 3가지 정리**
1. **값을 저장할 때** 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
2. **값을 참조할 때** 한 번에 읽어들여야 할 **메모리 공간의 크기**를 결정하기 위해
3. 메모리에서 읽어 들인 **2진수를 어떻게 해석할지** 결정하기 위해

## 6.10 동적 타이핑
### 6.10.1 동적 타입 언어와 정적 타입 언어
**정적 타입(static/strong type) 언어**
- 변수를 선언할 때 변수에 할당할 수 있는 데이터 타입을 사전에 선언해야 하는 언어
- 변수에 **선언한 타입에 맞는 값만 할당**할 수 있음
- 컴파일 시점에 타입 체크를 수행해서 통과하지 못하면 프로그램의 실행 자체를 막음
- 타입의 일관성을 강제함으로써 런타임에 발생하는 에러를 줄일 수 있음
- C, C++, Java, Kotlin, Go 등

**동적 타입(dynamic/weak type) 언어**
- 변수를 선언할 때 타입을 선언하지 않는 언어
- 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 **변수의 타입을 언제든지 자유롭게 변경**할 수 있음
- **동적 타이핑(dynamic typing)** : 선언이 아닌 할당에 의해 타입 추론(type inference)이 일어나는 것
- JavaScript, Python, PHP, Ruby 등

### 6.10.2 동적 타입 언어와 변수
동적 타입 언어에서 변수의 값은 언제든지 변경될 수 있기 때문에 변화하는 변수 값을 추적하기 어려울 수 있음<br>
따라서 동적 타입 언어는 **유연성(flexibility)** 은 높지만 **신뢰성(reliability)** 은 떨어짐

**변수를 사용할 때 주의 사항**
1. 변수는 꼭 필요한 경우에 한해 제한적으로 사용
2. 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제 : [**13장 스코프**]()
3. 전역 변수는 최대한 사용하지 않도록 함 : [**14장 전역 변수의 문제점**]()
4. 변수보다는 상수를 사용해 값의 변경을 억제 : [**15.3 const 키워드**]()
5. 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍