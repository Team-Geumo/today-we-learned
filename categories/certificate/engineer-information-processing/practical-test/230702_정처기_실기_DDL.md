# DDL (Data Definition Language)

## 1. 데이터 정의어(DDL)의 개념

- 데이터를 정의하는 언어로서 '데이터를 담는 그룻을 정의하는 언어'
- 테이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어들로 특정 구조를 생성, 변경, 삭제, 이름을 바꾸는 데이터 구조와 관련된 명령어들

<br>

## 2. DDL의 대상

|DDL 대상|설명|
|---|---|
|**도메인(Domain)**|- 하나의 속성이 가질 수 있는 원자값들의 집합<br> - 속성의 데이터 타입과 크기, 제약조건 등의 정보|
|**스키마(Schema)**|- 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조| 
|**테이블(Table)**|데이터 저장 공간|
|**뷰(View)**|하나 이상의 물리 테이블에서 유도되는 가상의 테이블|
|**인덱스(Index)**|검색을 빠르게 하기 위한 데이터 구조|

<br>

- 스키마의 구성
  |스키마의 구성|설명|
  |---|---|
  |**외부 스키마(External Schema)**|- 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조<br> - 사용자 뷰를 나타냄<br> - 서브 스키마로 불림|
  |**개념 스키마(Conceptual Schema)**|- 데이터베이스의 전체적인 논리적 구조<br> - 전체적인 뷰를 나타냄<br> - 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의|
  |**내부 스키마(Internal Schema)**|- 물리적 저장장치의 관점에서 보는 데이터베이스 구조<br> - 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현|

<br>

### 2.1. 테이블(Table)

#### 2.1.1. 테이블의 개념

- 데이터를 저장하는 항목인 필드(Field)들로 구성된 데이터의 집합체
- 하나의 DB 내에 여러 개의 테이블로 구성될 수 있고, 릴레이션(Relation) 혹은 엔터티(Entity)라고도 불림

#### 2.1.2. 테이블의 용어

|용어|설명|
|---|---|
|**튜플(Tuple) / 행(Row)**|- 테이블 내의 행을 의미하며 레코드(Record)라고도 함<br> - 튜플은 릴레이션(Relation)에서 같은 값을 가질 수 없음|
|**에트리뷰트(Attribute) / 열(Column)**|-  테이블 내의 열을 의미<br> - 열의 개수를 디그리(Degree)라고 함|
|**식별자(Identifier)**|- 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각의 구분할 수 있는 논리적인 개념|
|**카디널리티(Cardinality)**|튜플(Tuple)의 개수|
|**차수(Degree)**|애트리뷰트(Attribute)의 개수|
|**도메인(Domain)**|하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합|

<br>

### 2.2. 뷰(View)

#### 2.2.1 뷰의 개념

- 논리 테이블로서 사용자에게(생성 관점 아닌 사용 관점에서) 테이블과 통일
- 하나의 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있음
- 뷰와 같은 결과를 만들기 위해 조인 기능을 활용할 수 있으나, 뷰가 만들어져 있다면 사용자는 조인 없이 하나의 테이블을 대상으로 하는 단순한 질의어를 사용할 수 있음

#### 2.2.2. 뷰의 특징

|특징|설명|
|---|---|
|논리적 데이터 독립성 제공|데이터베이스에 영향을 주지 않고 애플리케이션이 원하는 형태로 데이터에 접근 가능|
|데이터 조작 연산 간소화|애플리케이션이 원하는 형태의 논리적 구조를 형성하여 데이터 조작 연산을 간소화|
|보안 기능(접근제어) 제공|특정 필드만을 선택해 뷰를 생성할 경우 애플리케이션은 선택되지 않은 필드의 조회 및 접근 불가|
|뷰 변경 불가|뷰 정의는 ALTER 문을 이용하여 변경할 수 없음<br> (뷰는 CREATE 문을 사용하여 정의, 뷰를 제거할 때에는 DROP 문을 사용)|

#### 2.2.3. 뷰의 목적

- 뷰를 사용하는 주된 이유는 단순 질의어를 사용할 수 있기 때문
- FROM 절에 있는 하나의 뷰를 통해 뷰를 구성하는 복수의 테이블을 대체하는 단순성에 그 의의가 있음
- 테이블의 중요 데이터 일부만을 제공할 수 있는 장단점이 있음

  |구분|장/단점|설명|
  |---|---|---|
  |장점|논리적 독립성 제공|- 뷰는 논리 테이블(테이블의 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨)|
  |장점|사용자 데이터 관리 용이|- 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능|
  |장점|데이터 보안의 용이|- 중요 보안 데이터를 저장 중인 테이블에는 접근 불허<br> - 해당 테이블의 일부 정보만을 볼 수 있는 뷰에는 접근을 허용<br> - 보안 데이터에 대한 접근 제어 가능|
  |단점|뷰 자체 인덱스 불가|- 인덱스는 물리적으로 저장된 데이터를 대상으로 하기에 논리적 구성인 뷰 자체는 인덱스를 가지지 못함|
  |단점|뷰 정의 변경 불가|- 뷰의 정의를 변경하려면 뷰를 삭제하고 재생성|
  |단점|데이터 변경 제약 존재|- 뷰의 내용에 대한 삽입, 삭제, 변경 제약이 있음|

<br>

### 2.3. 인덱스(Index)

#### 2.3.1. 인덱스의 개념

- 검색 연산의 최적화를 위한 데이터베이스 내 값에 대한 주소 정보로 구성된 데이터 구조
- 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회 속도를 높여 주는 자료 구조
- 테이블의 특정 레코드 위치를 알려주는 용도로 사용

#### 2.3.2. 인덱스의 특징

- 기본 키(PK; Primary Key) 컬럼은 자동으로 인덱스가 생성
- 연월일이나 이름을 기준으로 하는 인덱스는 자동으로 생성되지 않음
- 테이블의 컬럼에 인덱스가 없는 경우, 테이블의 전체 내용을 검색(테이블 전체 스캔; Table Full Scan)
- 인덱스가 생성되어 있을 때 데이터를 빠르게 찾을 수 있음(인덱스 범위 스캔; Index Range Scan)
- 조건절에 `=`로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있음

#### 2.3.3. 인덱스의 종류

|유형|설명|
|---|---|
|**순서 인덱스(Ordered Index)**|- 데이터가 정렬된 순서로 생성되는 인덱스<br> - B-Tree 알고리즘 활용(오름차순/내림차순 지정가능)|
|**해시 인덱스(Hash Index)**|- 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스<br> - 데이터 접근 비용이 균일, 튜플(Row) 양에 무관|
|**비트맵 인덱스(Bitmap Index)**|- 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스<br> - 수정 변경이 적을 경우 유용(생년월일, 상품번호 등)|
|**함수기반 인덱스(Functional Index)**|- 수식이나 함수를 적용하여 만든 인덱스|
|**단일 인덱스(Singled Index)**|- 하나의 컬럼으로만 구성한 인덱스<br> - 주 사용 컬럼이 하나일 경우 사용|
|**결합 인덱스(Concatenated Index)**|- 두 개 이상의 컬럼으로 구성한 인덱스<br> - WHERE 조건으로 사용하는 빈도가 높은 경우 사용|
|**클러스터드 인덱스(Clutered Index)**|- 기본 키(PK) 기준으로 레코드를 묶어서 저장하는 인덱스<br> - 저장 데이터의 물리적 순서에 따라 인덱스가 생성<br> - 특정 범위 검색 시 유리함|
